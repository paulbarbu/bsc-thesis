\documentclass[12pt,a4paper,titlepage]{report}

\usepackage{times}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[romanian]{babel}

\usepackage{setspace}
\onehalfspacing

\usepackage[hidelinks]{hyperref}

\usepackage{graphicx}

\author{Barbu Paul - Gheorghe}

%TODO: coperta
%TODO: plan tematic?

\begin{document}

\begin{titlepage}
{
\centering
UNIVERSITATEA "LUCIAN BLAGA" DIN SIBIU\\
FACULTATEA DE INGINERIE \\
DEPARTAMENTUL DE CALCULATOARE ŞI INGINERIE ELECTRICĂ\\
}

\vfill

{
\centering
\Large
Secured Bootloader: program pentru controlul secvenței de
inițializare și al actualizării aplicației în microcontrollere
programabile
}

\vfill
{
\raggedright
Conducător ştiinţific: TODO: c.d. cu  grad şi titlul de doctor \\
Îndrumător: TODO: c.d. ce s-a ocupat de student
}
\vfill

{
\raggedright
\hspace*{160pt}Absolvent: \\
\hspace*{160pt}Barbu Paul - Gheorghe\\
\hspace*{160pt}Specializarea:\\
\hspace*{160pt}Calculatoare și Tehnologia Informației
}

\end{titlepage}

\tableofcontents
\newpage

\subsection*{Prezentarea temei}

Lucrarea de față își propune dezvoltarea unui bootloader securizat pentru dispozitive embedded, aceste dispozitive conțin un microcontroller și în general utilizatorul respectivelor dispozitive nu vede și nu interacționează direct cu microcontroller-ul. Exemple de dispozitive embedded sau de aparate care conțin asemenea dispozitive: frigider, mașină de spălat, autoturism, termostat, contor electric, sistem de alarmă, sistem de supraveghere, ceasuri, etc.

Un bootloader este o aplicație care este în general încărcată pe microcontroller de către firma care vinde microcontroller-ul și care nu poate fi înlocuită ușor de către utilizatorii acestuia.
Rolul acestei aplicații este de a fi gazda ("host"-ul) și de a face verificările necesare încărcării unei alte aplicații pe microcontroller. În urma verificărilor se poate afirma că aplicația "guest" sau utilizator este una validă și că poate fi rulată de microcontroller cu încredere.
În urma procesului de bootloading ambele aplicații, atât bootloader-ul cât și aplicația utilizator, vor coexista în
memoria non-volatilă a dispozitivului embedded\footnote{în general pe flash-ul microcontroller-ului, conform unui memory map predefinit de producător}.
 
Motivele pentru care bootloader-ul este securizat și pentru care înlocuirea lui sau a aplicației utilizator
nu ar trebui să poată fi făcută de oricine țin în mică parte de protejarea proprietății intelectuale a celor ce creează aplicații guest pentru respectivul dispozitiv și într-o mai mare măsură țin de asigurarea integrității și a evitării modificării neautorizate a acestei aplicații pentru a asigura utilizatorului experiența pe care producătorul dispozitivelor embedded și-a imaginat-o. Acest lucru este crucial în ziua de astăzi, când criminalitatea în mediul cibernetic este în creștere\cite{interpol}\cite{morgan2016}. Consumatorii trebuie să poată fi protejați proactiv de acțiunile ilegale ale crackerilor, în antiteză cu metoda tradițională, reactivă care constă în schimbarea și îmbunătățirea unui sistem după ce acesta a fost compromis. Cele două metode se complementează reciproc, dar metoda proactivă are avantajul prevenirii unei acțiuni malițioase asupra sistemului informatic.

În afară de îmbunătățirea securității unui sistem embedded precum a fost descris mai sus, rolul bootloader-ului ar trebui să fie și de a mări flexibilitatea unui astfel de sistem. Acest rol este îndeplinit prin faptul că aplicația utilizator de pe microcontroller poate fi schimbată fără modificări hardware asupra sistemului. Schimbarea aplicației utilizator poate surveni din diverse motive, printre care: dezvoltatorul sistemului embedded hotărăște că este timpul să introducă funcționalități noi în aplicație sau că aplicația veche are unele defecte (bug-uri) care trebuie reparate sau chiar că sistemul embedded care înainte îndeplinea un rol trebuie să îndeplinească un rol complet nou, diferit față de cel vechi. Toate aceste scenarii implică folosirea bootloader-ului pre-instalat pe un dispozitiv pentru a încărca o altă aplicație (fie că e una complet nouă sau doar puțin modificată datorită remedierii defectelor din versiunea anterioară).

Bootloader-ul dezvoltat ar trebui să ne permită de asemenea reducerea costurilor. Prin costuri putem să considerăm de exemplu costurile survenite în urma livrării unui sistem embedded. Prin definiție mecanismele interne ale unui astfel de sistem nu sunt accesibile consumatorilor, deci orice modificare, fie ea chiar și software trebuie să fie făcută de producător. Așadar dispozitivul trebuie să fie livrat la producător, acesta aplică modificările și livrează înapoi dispozitivul clientului. Prin intermediul bootloader-ului ne propunem să putem face aceste modificări software la distanță. În esență aceste modificări se vor putea face independent de către fiecare utilizator al sistemului.

Succint cerințele pe care trebuie să le satisfacă bootloader-ul sunt:
\begin{itemize}
\item asigurarea flexibilității dispozitivului embedded prin faptul ca aplicațiile de utilizator se pot schimba la nevoie
\item asigurarea securității și integrității unui sistem embedded în momentul în care aplicația este încărcată\footnote{securitatea sistemului depinde 100\% de aplicație în momentul în care aceasta rulează}
\item minimizarea costurilor de întreținere a dispozitivelor embedded dintr-un mediu industrial prin posibilitatea de a acționa bootloader-ul din exteriorul sistemului embedded
\end{itemize}

Prin rezolvarea acestor puncte, bootloader-ul va fi de ajuns de generic pentru aplicabilitate în diverse domenii și pe diverse platforme hardware. Fiind vorba de mediul embedded, bootloader-ul a fost proiectat și dezvoltat cu constrângerile de mărime în minte, cu atât mai mult cu cât pe un microcontroller se vor stoca două aplicații simultan, bootloader-ul și aplicația utilizator, dar doar una va rula la un moment dat.

\newpage
\chapter{Considerații teoretice}
\section{Introducere și etimologie}
Un bootloader se află pe orice sistem de calcul care trebuie să încarce un sistem de operare sau o aplicație terță.
Acest lucru este valabil fie că utilizatorul interacționează cu sistemul în timpul procesului de "boot" fie că procesul se petrece automat, fără interacțiune umană.

Cuvântul bootloader vine de la procesul de "boot" (sau "boot up"), care la rândul său este o scriere prescurtată a "bootstrap". Bootstrap în engleză semnifică "to pull oneself up by one's bootstraps", procesul prin care noi pornim la drum încălțându-ne. \cite{wikiBootstrap}

\section{Modul de funcționare al unui bootloader}
Orice bootloader trebuie stocat într-o memorie non-volatilă și de preferat disponibilă doar pentru citire, o memorie ROM\footnote{Read-Only Memory}, deoarece acesta trebuie să fie disponibil în momentul în care sistemul pornește indiferent de ce s-a întâmplat anterior pe sistem. Acest lucru garantează funcționarea corectă a sistemului și faptul că sistemul de operare sau aplicația utilizator poate fi schimbată. În caz contrar, când sistemul încetează să funcționeze din cauza unui defect (în general software) putem spune ca este "brick-uit", de la englezescul "brick" (cărămidă)\cite{wikiBrick}.

Un bootloader este, fără excepție, primul program executat de către un procesor, bine-înțeles cu excepția BIOS-ului\footnote{Basic Input/Output System} pe x86, dar putem ignora această particularitate, deoarece pe sistemele embedded, noțiunea de BIOS nu există.
În linii mari codul bootloader-ului este încărcat de pe discul solid\footnote{ROM la dispozitive embedded} în RAM\footnote{Random - Access Memory}, apoi este executat, iar în urma execuției acestui cod (în mod tipic un sector) se poate întâmpla unul din două lucruri:
\begin{enumerate}
\item bootloader-ul și-a încheiat treaba și a predat controlul aplicației utilizator respectiv sistemului de operare
\item bootloader-ul nu încape într-un sector și codul executat anterior este doar auxiliar
\end{enumerate}
Prima variantă este cea trivială. În al doilea caz avem de a face cu un așa zis "two stage bootloader", în primul stagiu făcându-se doar apelul spre acest stagiu secundar. Aici se va face de fapt încărcarea aplicației utilizator. Motivul din spatele încărcării în două faze este faptul că, fără drivere de disc și fără sisteme de fișiere, unitatea maximă pe care procesorul o poate citi de pe hard disc este sectorul, așadar intervin limitări legate de mărimea codului care poate fi executat la un moment dat.

Posibila diferență la sistemele embedded este aceea că microcontroller-ul poate executa cod direct din memoria flash și că bootloader-ul este probabil mai mic ca un sector, deoarece aplicațiile sunt reduse ca dimensiune și ca periferice cu care pot interacționa, display-ul și tastatura nefiind necesare în astfel de sisteme în timpul procesului de boot up.

La calculatoarele personale un bootloader bine cunoscut și pentru care avem nevoie de display și tastatură este GNU GRUB, folosit de majoritatea distribuțiilor GNU/Linux. Acest bootloader este vizibil utilizatorului (pe ecran, prin intermediul unui meniu asemănător cu cel din figura \ref{grub2menu}), iar în cazul sistemelor dual-boot sau multi-boot se poate chiar schimba sistemul de operare ce urmează a fi încărcat, acest lucru se face folosind tastatura.
\begin{figure}[h]
    \centering
    \includegraphics{grub}
    \caption{Meniul GRUB2}
    \label{grub2menu}
\end{figure}

\section{Studiu de caz: secvența de boot la PC}
Deși nu este în domeniul bootloader-ului, datorită omniprezenței acestor tipuri de procesoare merită să ne familiarizăm cu secvența de pași pe care un procesor din familia x86 o execută atunci când este pornit.
Această secvență fiind în strânsă relație cu pornirea bootloader-ului.

La pornire procesorul intră în modul real și execută instrucțiunea de la adresa \texttt{0xFFFFFFF0}\footnote{pe sisteme 32 si 64 bit} \cite{intel80386} \cite{intel64}. În mod normal această locație conține o instrucțiune de salt la locația de start a BIOS-ului care se află într-o memorie ROM.
BIOS-ul este de fapt primul program care se execută pe această arhitectură, nu direct bootloader-ul, în contradicție cu ceea ce am precizat anterior. Rolul BIOS-ului este de a inițializa hardware-ul și de a-l abstractiza, acesta rămânând tot timpul în funcțiune \cite{wikiBootSeq}.

Pasul de inițializare făcut de BIOS, poartă denumirea de POST\footnote{Power-On Self Test}, pas în care BIOS-ul pregătește memoria RAM și bus-urile pentru a putea începe comunicația cu perifericele a căror prezență urmează să o verifice. Aceste verificări sunt necesare, deoarece contrar unui sistem embedded, intr-un calculator personal pot apărea și dispărea componente de la o pornire la alta, de exemplu putem adăuga o placă de rețea sau putem scoate placa video, în oricare dintre aceste cazuri BIOS-ul trebuie să știe de prezența unui periferic nou sau de lipsa unuia vechi pentru a putea prezenta toate aceste informații nivelelor superioare, care vor pune în funcțiune perifericele respective.
\begin{figure}[h]
    \centering
    \includegraphics{structuraPC}
    \caption{Structura "cochilie" a PC-ului}
    \label{shellArchitecture}
\end{figure}
Se poate observa în figura \ref{shellArchitecture} că BIOS-ul abstractizează hardware-ul, acest lucru este făcut mai departe și de sistemul de operare prin intermediul driverelor și prin intermediul apelurilor de sistem\footnote{"syscalls" sau "system calls" în engleză}. Datorită poziționării lor în centrul cochiliei, din aceeași figură reiese că aplicațiile beneficiază de cel mai mare nivel de abstractizare, ele nu trebuie să știe detalii intime despre așezarea datelor pe hard disk, în schimb au la dispoziție conceptul de fișier, indiferent de câte sectoare ocupă un asemenea fișier sau cum se comandă citirea lui la nivelele inferioare ale arhitecturii.

După inițializarea perifericelor, BIOS-ul trece printr-o listă pre-configurată de dispozitive de stocare non-volatile
până când găsește unul boot-abil. Un asemenea dispozitiv este caracterizat de faptul că ultimii doi octeți ai primului sector sunt egali cu \texttt{0x55AA}, aceasta reprezentând "semnătura" unui disc boot-abil.
Cel mai probabil această secvență \texttt{0x55AA} a fost aleasă deoarece în binar ea arată așa: \texttt{0101 0101 1010 1010}, observăm că biții sunt destul de variați, schimbarea în cascadă a lor neproducând din nou aceeași valoare și putând evita astfel încărcarea unui sector invalid sau corupt.

Odată ce discul boot-abil a fost găsit primul lui sector este încărcat în memorie și executat, aici se află în sfârșit bootloader-ul. Codul este încărcat la adresa \texttt{0x0000:0x7C00} \cite{biosMBRaddr}.

În urma execuției bootloader-ul poate alege în mod automat de unde încarcă sistemul de operare sau, în cazul multi-boot, pasează această responsabilitate utilizatorului, punându-l să aleagă sistemul de operare dorit dintr-o listă.

În acest prim sector se află MBR-ul\footnote{Master Boot Record}. În cele mai multe cazuri cu o dimensiune de 512 octeți, MBR-ul conține de fapt codul bootloader-ului și detalii despre partiționarea discului. Codul bootloader-ului poate fi acela al lui GRUB sau bootloader-ul instalat de sistemele de operare Windows.

Structura MBR-ului este prezentată în tabelul \ref{mbrStruct}.

\begin{table}[h]
    \begin{tabular}{ | c | c | c | }
        \hline
        \textbf{Adresă} & \textbf{Descriere} & \textbf{Mărime (octeți)} \\ \hline
        \texttt{0x000} & Codul bootloader-ului & 446 \\ \hline
        \texttt{0x1BE} & Prima tabelă de partiție & 16 \\ \hline
        \texttt{0x1CE} & A doua tabelă de partiție & 16 \\ \hline        
        \texttt{0x1DE} & A treia tabelă de partiție & 16 \\ \hline
        \texttt{0x1EE} & A patra tabelă de partiție & 16 \\ \hline
        \texttt{0x1FE} & Primul octet al semnăturii discului (\texttt{0x55}) & 1 \\ \hline
        \texttt{0x1FF} & Al doilea octet al semnăturii discului (\texttt{0xAA}) & 1 \\ \hline
    \end{tabular}
    \centering
    \caption{Structura MBR-ului}
    \label{mbrStruct}
\end{table}

Din tabelul \ref{mbrStruct} se poate observa de asemenea că bootloader-ul este în realitate constrâns la mai puțin de 512 octeți, deoarece MBR-ul conține atât semnătura unui disc boot-abil, folosită de BIOS, cât și informații despre partițiile primare existente pe mediul de stocare. Pe scurt, tabelele de partiții au structura din tabelul \ref{partitionTableStruct} \cite{wikiPTE} și ele indică unde începe și unde se termină o partiție pe disc, cât și tipul acesteia și faptul că ea conține sau nu un sistem de operare, informație folosită apoi de bootloader pentru a popula lista de sisteme de operare disponibile pe calculator. Așadar dacă bootlodaer-ul, în urma inspectării tabelelor de partiții, găsește doar una activă, o va alege automat, în caz contrar îi va prezenta utilizatorului o listă cu sistemele de operare (respectiv partițiile pe care se află acestea) spre a face alegerea.

\begin{table}[h]
    \begin{tabular}{ | c | c | c | }
        \hline
        \textbf{Adresă} & \textbf{Descriere} & \textbf{Mărime (octeți)} \\ \hline
        \texttt{0x0} & Partiție activă sau nu (conține sau nu un sistem de operare) & 1 \\ \hline
        \texttt{0x1} & Adresa Cilindru-Cap-Sector de început a partiției & 3 \\ \hline
        \texttt{0x4} & Tipul partiției & 1 \\ \hline
        \texttt{0x5} & Adresa Cilindru-Cap-Sector de final a partiției & 3 \\ \hline
        \texttt{0x8} & Adresa logică a blocului (LBA) de început a partiției & 4 \\ \hline
        \texttt{0xC} & Numărul de sectoare al partiției & 4 \\ \hline
    \end{tabular}
    \centering
    \caption{Structura sumară a unei tabele de partiție}
    \label{partitionTableStruct}
\end{table}

%TODO: despre EFI si lipsa MBR-ului: https://en.wikipedia.org/wiki/Master_boot_record#System_bootstrapping

TODO: %https://msdn.microsoft.com/en-us/library/ms902397.aspx

TODO:% https://en.wikipedia.org/wiki/Master_boot_record\#Programming_considerations

TODO: despre alte bootloadere la PC: grub, lilo

\section{Studiu de caz: secvența de boot la un sistem embedded}

TODO: despre cum se scrie codul in lumea embedded, fara bootloader prima data (flashuirea din fabrica)

TODO: analogie cu structura shell la PC, in loc de bios, drivere si SO avem direct biblioteci

TODO: %Standard Startup Sequenc: https://mcuoneclipse.com/2014/06/15/tutorial-diy-kinetis-sdk-project-with-eclipse-startup/

TODO: despre alte bootloadere embedded

\newpage
\chapter{Rezolvarea temei de proiect}
\section{Introducere}
TODO: memory map, cum sta aplicatia host si guest in memorie

TODO: scrie-ma

TODO: %https://mcuoneclipse.com/2013/04/19/why-i-dont-like-printf/

TODO: %size_comp_debug_release.ods

\section{Concluzii și dezvoltări ulterioare}

TODO: scrie-ma


\newpage
\bibliographystyle{plain}
\bibliography{bibliografie}

\end{document}
